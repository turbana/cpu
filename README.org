* TIM-16
TIM-16 will be a custom designed computer, built from 74 series CMOS logic chips.

** Architecture
 - 5 stage pipelined RISC architecture
 - 16 bit ALU
 - 8 16 bit general purpose registers
 - 8 control registers
 - 22 bit word addressed memory (8MB)
 - Precise external interrupts using an 8259A PIC
 - No support for exceptions or control codes
 - Memory mapped IO with support for 2 serial ports, an IDE hard disk, and a 555 timer with room to expand
 - User/Supervisor modes 
 - Segmentation as a memory protection scheme
 - Separate data and instruction memories
 - 22 bit physical addressing divided into 64 segments, each with 64k words of instruction and data memory

** Instruction Set
| Inst     | Form                  | Meaning                                       |
|----------+-----------------------+-----------------------------------------------|
| add      | r1, r2, [r3\vert{}sp] | r1 := r2 + r3                                 |
| sub      | r1, r2, [r3\vert{}sp] | r1 := r2 - r3                                 |
| and      | r1, r2, [r3\vert{}sp] | r1 := r2 & r3                                 |
| or       | r1, r2, [r3\vert{}sp] | r1 := r2 \vert r3                             |
| shl      | r1, r2, [r3\vert{}sp] | r1 := r2 << r3                                |
| shr      | r1, r2, [r3\vert{}sp] | r1 := r2 >> r3                                |
| sar      | r1, r2, [r3\vert{}sp] | r1 := r2 <<< r3                               |
| xor      | r1, r2, [r3\vert{}sp] | r1 := r2 ^ r3                                 |
| s.{cond} | r1, [r2\vert{}sp]     | skip next if (r1 <cond> r2)                   |
| as.z     | r1, r2, [r3\vert{}sp] | r1 := r2 + r3; skip next if r1 == 0           |
| as.nz    | r1, r2, [r3\vert{}sp] | r1 := r2 + r3; skip next if r1 != 0           |
| jmp      | [r1\vert{}sp](r2)     | pc := r1 + r2                                 |
| ldw      | r1, [r2\vert{}sp](r3) | r1 := Md[r2 + r3]                             |
| stw      | [r1\vert{}sp](r2), r3 | Md[r1 + r2] := r3                             |
| ldiw     | r1, [r2\vert{}sp](r3) | r1 := Mi[r2 + r3]                             |
| stiw     | [r1\vert{}sp](r2), r3 | Mi[r1 + r2] := r3                             |
| ldw      | r1, imm7(r2)          | r1 := Md[r2 + imm]                            |
| stw      | imm7(r1), r2          | Md[r1 + imm] := r2                            |
| lcr      | r1, cr1               | r1 := cr1                                     |
| scr      | cr1, r1               | cr1 := r1                                     |
| lui      | r1, uimm8             | r1 := imm << 8                                |
| addi     | r1, uimm8             | r1 := r1 + imm                                |
| jmp      | imm11                 | pc := pc + imm                                |
| trap     |                       | Enter supervisor mode; jump to kernel routine |
| halt     |                       | Execution halts                               |
| iret     |                       | Enter user mode; jump to $epc                 |

***** Special Immediates
8 possible values: 1, 2, 4, 8, -1, -2, -4, -8

***** Conditionals
| s.eq   | ==          |
| s.ne   | !=          |
| s.gt   | >           |
| s.gte  | >=          |
| s.lt   | <           |
| s.lte  | <=          |
| s.ult  | unsigned <  |
| s.ulte | unsigned <= |

** Registers
*** General Purpose Registers
| Register | Alias | Writable | Meaning                          |
|----------+-------+----------+----------------------------------|
| $0       |       | No       | Always reads 0                   |
| $1       |       | Yes      | General Purpose                  |
| $2       |       | Yes      | General Purpose                  |
| $3       |       | Yes      | General Purpose                  |
| $4       |       | Yes      | General Purpose                  |
| $5       |       | Yes      | General Purpose                  |
| $6       | $fp   | Yes      | Frame/Link Pointer by convention |
| $7       | $sp   | Yes      | Stack Pointer by convention      |

*** Control Registers
Control Registers can only be accessed with LCR/SCR instructions. With the exception of $pc, control registers can only be accessed in supervisor mode. Illegal reads and writes are ignored.

| Register | Alias  | Writable | Mode       | Meaning                                          |
|----------+--------+----------+------------+--------------------------------------------------|
| $cr0     | $pc    | No       | Any        | Program Counter                                  |
| $cr1     | $ds    | Yes      | Supervisor | Data Segment (prepended to data memory accesses) |
| $cr2     | $cs    | Yes      | Supervisor | Code Segment (prepended to code memory accesses) |
| $cr3     | $flags | Yes      | Supervisor | Processor Flags (see below)                      |
| $cr4     | $epc   | Yes      | Supervisor | Exceptional Program Counter                      |
| $cr5     | $eds   | Yes      | Supervisor | Exceptional Data Segment                         |
| $cr6     | $ecs   | Yes      | Supervisor | Exceptional Code Segment                         |
| $cr7     | $isr   | No       | Supervisor | Interrupt Service Routine                        |

**** $cr3 - Flags Register
|  Bit | Name | Meaning                                     |
|------+------+---------------------------------------------|
|    0 | IE   | 0=Interrupts Disabled; 1=Interrupts Enables |
|    1 | M    | 0=Supervisor Mode; 1=User Mode              |
| 2-15 |      | Reserved                                    |

** Memory
Segmentation is used for memory protection. The corresponding segment register ($cs/$ds) is prepended to the logical address, forming the physical address that is sent across the bus. Segment 0 is considered the supervisor's segment and all devices are memory mapped onto this segment. Each process is assigned it's own code and data segments. Segment registers can only be accessed from supervisor mode, isolating processes from one another.

*** Data Memory Layout
| 0x00 0000 | RAM      |
| 0x00 FF7F |          |
| 0x00 FF80 | PIC      |
| 0x00 FF8F |          |
| 0x00 FF90 | UART0    |
| 0x00 FF9F |          |
| 0x00 FFA0 | UART1    |
| 0x00 FFAF |          |
| 0x00 FFB0 | 555      |
| 0x00 FFBF |          |
| 0x00 FFC0 | IDE      |
| 0x00 FFCF |          |
| 0x00 FFD0 | Reserved |
| 0x00 FFFF |          |
| 0x01 0000 | RAM      |
| 0xFF FFFF |          |

*** Instruction Memory Layout
| 0x00 0000 | RAM    |
| 0x00 DFFF |        |
| 0x00 E000 | EEPROM |
| 0x00 FFFF |        |
| 0x01 0000 | RAM    |
| 0xFF FFFF |        |
