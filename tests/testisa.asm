;;
;; Test ISA
;;
; TODO add memory tests
;
; final check |@| 256 ($1=F00D)

	.data
n:	.dw	0xABCD
m:	.dw	0x0000
	.zero	32
sbp:

	.text
	.ldi	$4, n			; $4 = &n			|@|   1 ($4=0000)
	.ldi	$6, m			; $6 = &m			|@|   3 ($6=0001)
	add	$5, $0, 2		; $5 = 2			|@|   4 ($5=0002)
					;
1:	ldw	$1, 0($4)		; $1 = n			|@|   5 ($1=ABCD)
	stw	0($6), $1		;  m = n			<memory test>
	shl	$2, $1, 8		; $2 = n << 8			|@|   7 ($2=CD00)
	shr	$3, $1, 8		; $3 = n >> 8			|@|  8 ($3=00AB)
	or	$1, $3, $2		; $1 = $3 | $2			|@|  9 ($1=CDAB)
	stw	0($4), $1		;  n = $1			<memory test>
	as.z	$5, $5, -1		; $5 -= 1; loop until 0		|@|  11 ($5=0001)
	jmp	1b			;				|@|  12 ($5=0001)
					;				|@|  19 ($1=ABCD $2=AB00 $3=00CD $5=0000)
	ldw	$1, 0($4)		; $1 = n (0xABCD)		|@|  20 ($1=ABCD)
	ldw	$2, 0($6)		; $2 = m (0xCDAB)		|@|  21 ($2=CDAB)
	sub	$3, $0, -4		; $3 = 4			|@|  22 ($3=0004)
1:	shl	$1, $1, 1		; $1 <<= 1			|@|  23 ($1=579A)
	shr	$2, $2, 1		; $2 >>= 1			|@|  24 ($2=66D5)
	sub	$3, $3, 1		; $3 -= 1			|@|  25 ($3=0003)
	s.eq	$3, $0			; loop until $3 == 0
	jmp	1b			;
					;				|@|  41 ($1=BCD0 $2=0CDA $3=0000)
	or	$3, $1, $2		; $3 = $1 | $2			|@|  42 ($3=BCDA)
	stw	$0($4), $3		;  n = $3			<memory test>
	ldw	$1, $0($4)		; $1 = n			|@|  44 ($1=BCDA)
	ldw	$2, $0($6)		; $2 = m			|@|  45 ($2=CDAB)
	xor	$3, $1, $2		; $3 = 0xBCDA ^ 0xCDAB = 0x7171	|@|  46 ($3=7171)
	shl	$2, $3, 1		; $2 = $3 << 1 = 0xE2E2		|@|  47 ($2=E2E2)
	lui	$1, 0x80		; $1 = 0x8000			|@|  48 ($1=8000)
	or	$1, $1, $3		; $1 = $1 | $3 = 0xF171		|@|  49 ($1=F171)
	xor	$3, $3, $3		; $3 = $3 ^ $3 = 0		|@|  50 ($3=0000)
	sub	$3, $0, 1		; $3 = -1			|@|  51 ($3=FFFF)
	stw	0($6), $3		;  m = $3			<memory test>
	add	$3, $0, -1		; $3 = 0xFFFF			|@|  53 ($3=FFFF)
	shr	$3, $3, 8		; $3 >>= 8 = 0x00FF		|@|  54 ($3=00FF)
	sext	$2, $3			; $2 = sext $3 = 0xFFFF		|@|  55 ($2=FFFF)
	and	$1, $1, $2		; $1 = $1 & $2 = 0xF171		|@|  56 ($1=F171)
					;
	.ldi	$7, sbp			; setup stack			|@|  58 ($7=0022)
	.push	$1			; push 0xF171			|@|  60 ($7=0021)
					;				<memory test>
	sub	$7, $7, 1		; .call count_bits		|@|  61 ($7=0020)
	lcr	$5, $cr0		;				|@|  62 ($5=002B)
	add	$5, $5, 2		;				|@|  63 ($5=002D)
	stw	0($7), $5		;				<memory test>
	jmp	count_bits		;
	.pop	$2			; $2 = result = 9		|@| 178 ($2=0009)
					;				|@| 179 ($7=0022)
	xor	$3, $1, $2		; $3 = $1 ^ $2 = 0xF178		|@| 180 ($3=F178)
					;
	.ldi	$1, test		; $1 = &test			|@| 182 ($1=0034)
	lcr	$2, $cr0		; $2 = PC + 2 (&test)		|@| 183 ($2=0034)
	add	$0, $0, $0		; noop
test:	s.eq	$1, $2			; skip if same address
	add	$3, $3, $1		; scramble $3
					;				|@| 185 ($3=F178)
	shr	$3, $3, 1		; $3 >>= 1 = 0x78BC		|@| 186 ($3=78BC)
	.ldi	$5, 0x8000		; $5 = 0x8000			|@| 187 ($5=8000)
	or	$3, $3, $5		; $3 |= $5 = 0xF8BC		|@| 188 ($3=F8BC)
					;
	add	$3, $3, 1		; $3 += 1 (0xF8BD)		|@| 189 ($3=F8BD)
	ldw	$2, 0($6)		; $2 = m (0xFFFF)		|@| 190 ($2=FFFF)
	ldw	$1, 0($6)		; $1 = m (0xFFFF)		|@| 191 ($1=FFFF)
	.ldi	$5, 12			; $5 = 12 (shift count)		|@| 193 ($5=000C)
1:	shl	$1, $1, 1		; $1 <<= 1			|@| 194 ($1=FFFE)
	shr	$2, $2, 1		; $2 >>= 1			|@| 195 ($2=7FFF)
	as.z	$5, $5, -1		; dec 5, skip if zero		|@| 196 ($5=000B)
	jmp	1b			; loop
					;				|@| 240 ($1=F000 $2=000F $3=F8BD $5=0000)
	or	$1, $1, $2		; $1 = $1 | $2 (0xF00F)		|@| 241 ($1=F00F)
	and	$1, $1, $3		; $1 = $3 & $1 = 0xF00D		|@| 242 ($1=F00D)
					;
	add	$2, $0, 2		; $2 = 2			|@| 243 ($2=0002)
	add	$3, $2, 1		; $3 = 3			|@| 244 ($3=0003)
	add	$4, $3, 1		; $4 = 4			|@| 245 ($4=0004)
	add	$5, $4, 1		; $5 = 5			|@| 246 ($5=0005)
	add	$6, $0, -1		; $6 = -1			|@| 247 ($6=FFFF)
	add	$7, $0, 1		; $7 = 1			|@| 248 ($7=0001)
					;
	s.ne	$2, $3			; test skips			|@| 249 ($1=F00D)
	add	$1, $1, 1		; we shouldn't hit any adds
	s.gt	$7, $6			;				|@| 250 ($1=F00D)
	add	$1, $1, 1		;
	s.gte	$2, $7			;				|@| 251 ($1=F00D)
	add	$1, $1, 1		;
	s.lt	$4, $5			;				|@| 252 ($1=F00D)
	add	$1, $1, 1		;
	s.lte	$6, $2			;				|@| 253 ($1=F00D)
	add	$1, $1, 1		;
	s.ult	$7, $6			;				|@| 254 ($1=F00D)
	add	$1, $1, 1		;
	s.ulte	$7, $2			;				|@| 255 ($1=F00D)
	add	$1, $1, 1		;
					;
	jmp	0			;				|@| 256 ($1=F00D $cr0=0058)
					;
count_bits:				;				|@|  65 ($1=F171)
	.push	$1			; preserve $1			|@|  66 ($7=001F)
					;				<memory test>
	ldw	$1, 2($7)		; $1 = argument = 0xF171	|@|  67 ($1=F171)
	.push	$2			; preserve $2			|@|  69 ($7=001E)
					;				<memory test>
	.push	$3			; preserve $3			|@|  71 ($7=001D)
					;				<memory test>
	.push	$4			; preserve $4			|@|  73 ($7=001C)
					;				<memory test>
	add	$2, $0, $0		; $2 = 0			|@|  75 ($2=0000)
	.ldi	$4, 16			; $4 = 16 (bits)		|@|  77 ($4=0010)
1:	and	$3, $1, 1		; $3 = $1 & 1			|@|  78 ($3=0001)
	s.eq	$3, $0			; skip if 0
	add	$2, $2, 1		; inc $2			|@|  80 ($2=0001)
	shr	$1, $1, 1		; $1 = $1 >> 1			|@|  81 ($1=78B8)
	as.z	$4, $4, -1		; dec $4, skip when done	|@|  82 ($4=000F)
	jmp	1b			; loop				|@| 165 ($1=0000 $2=0009 $3=0001 $4=0000)
	.pop	$4			; restore $4			|@| 166 ($4=0000)
					;				|@| 167 ($7=001D)
	stw	4($7), $2		; result = $2 = 9		<memory test>
	.pop	$3			; restore $3			|@| 169 ($3=00FF)
					;				|@| 170 ($7=001E)
	.pop	$2			; restore $2			|@| 171 ($2=FFFF)
					;				|@| 172 ($7=001F)
	.pop	$1			; restore $1			|@| 173	($1=F171)
					;				|@| 174 ($7=0020)
	.pop	$5			; .ret				|@| 175 ($5=002D)
					;				|@| 176 ($7=0021)
	jmp	$5			;
